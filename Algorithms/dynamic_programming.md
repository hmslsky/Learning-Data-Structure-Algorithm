# 动态规划

## 1. 基本概念

### 1.1 什么是动态规划
- 动态规划是一种通过把原问题分解为相对简单的子问题来解决复杂问题的方法
- 动态规划常常适用于有重叠子问题和最优子结构性质的问题
- 动态规划方法所耗时间往往远少于朴素解法

### 1.2 动态规划的特点
- **重叠子问题**：子问题会被重复计算多次
- **最优子结构**：问题的最优解包含其子问题的最优解
- **无后效性**：当前状态只与之前的状态有关，与之后的状态无关

### 1.3 动态规划的基本要素
- **状态定义**：定义问题的状态
- **状态转移方程**：描述状态之间的转移关系
- **初始状态**：确定初始状态的值
- **计算顺序**：确定状态的计算顺序

## 2. 解题步骤

### 2.1 问题分析
1. 判断是否可以使用动态规划
2. 确定问题的状态
3. 确定状态转移方程
4. 确定初始状态
5. 确定计算顺序

### 2.2 实现方法
1. **自顶向下（记忆化搜索）**
   - 使用递归实现
   - 使用记忆化数组避免重复计算
   - 优点：实现简单，易于理解
   - 缺点：递归调用开销大

2. **自底向上（迭代）**
   - 使用循环实现
   - 按照计算顺序依次计算状态
   - 优点：效率高，空间利用率好
   - 缺点：实现可能较复杂

## 3. 经典问题

### 3.1 斐波那契数列
- **问题描述**：计算第n个斐波那契数
- **状态定义**：dp[i]表示第i个斐波那契数
- **状态转移方程**：dp[i] = dp[i-1] + dp[i-2]
- **初始状态**：dp[0] = 0, dp[1] = 1
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)（优化后）

### 3.2 最长公共子序列
- **问题描述**：求两个字符串的最长公共子序列
- **状态定义**：dp[i][j]表示str1[0...i]和str2[0...j]的最长公共子序列长度
- **状态转移方程**：
  - 如果str1[i] == str2[j]：dp[i][j] = dp[i-1][j-1] + 1
  - 否则：dp[i][j] = max(dp[i-1][j], dp[i][j-1])
- **时间复杂度**：O(mn)
- **空间复杂度**：O(mn)

### 3.3 0-1背包问题
- **问题描述**：在容量限制下选择物品使总价值最大
- **状态定义**：dp[i][j]表示前i个物品在容量j下的最大价值
- **状态转移方程**：
  - 如果j >= weight[i]：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
  - 否则：dp[i][j] = dp[i-1][j]
- **时间复杂度**：O(nW)
- **空间复杂度**：O(W)（优化后）

## 4. 优化技巧

### 4.1 空间优化
- 使用滚动数组
- 压缩状态表示
- 使用位运算优化

### 4.2 时间优化
- 使用记忆化搜索
- 优化状态转移方程
- 使用数据结构加速

### 4.3 其他优化
- 状态压缩
- 预处理
- 剪枝

## 5. 实际应用

### 5.1 字符串处理
- 编辑距离
- 最长回文子串
- 正则表达式匹配

### 5.2 图论问题
- 最短路径
- 最长路径
- 最小生成树

### 5.3 组合优化
- 旅行商问题
- 调度问题
- 资源分配

## 6. 注意事项

### 6.1 常见错误
- 状态定义不准确
- 状态转移方程错误
- 初始状态设置不当
- 计算顺序错误

### 6.2 调试技巧
- 打印状态表
- 验证状态转移
- 检查边界条件
- 使用小规模测试用例

### 6.3 性能考虑
- 空间复杂度优化
- 时间复杂度优化
- 内存使用优化
- 代码可维护性 